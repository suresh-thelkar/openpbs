/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of both the OpenPBS software ("OpenPBS")
 * and the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * OpenPBS is free software. You can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * OpenPBS is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * PBS Pro is commercially licensed software that shares a common core with
 * the OpenPBS software.  For a copy of the commercial license terms and
 * conditions, go to: (http://www.pbspro.com/agreement.html) or contact the
 * Altair Legal Department.
 *
 * Altair's dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of OpenPBS and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair's trademarks, including but not limited to "PBS™",
 * "OpenPBS®", "PBS Professional®", and "PBS Pro™" and Altair's logos is
 * subject to Altair's trademark licensing policies.
 */

/**
 * @file    run_sched.c
 *
 * @brief
 * 		run_sched.c	-	Functions related to the scheduler.
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include "portability.h"
#include <errno.h>
#include <netinet/in.h>
#include "log.h"
#include "libpbs.h"
#include "net_connect.h"
#include "sched_cmds.h"
#include "dis.h"
#include "list_link.h"
#include "attribute.h"
#include "job.h"
#include "server.h"
#include "pbs_nodes.h"
#include "svrfunc.h"
#include "work_task.h"
#include "pbs_error.h"
#include "batch_request.h"
#include "pbs_sched.h"
#include "queue.h"
#include "pbs_share.h"
#include "pbs_sched.h"
#include <netinet/tcp.h>


/* Global Data */

extern struct server server;
extern pbs_net_t pbs_scheduler_addr;
extern unsigned int pbs_scheduler_port;
extern char      server_name[];
extern struct connection *svr_conn;
extern int	 svr_do_schedule;
extern int	 svr_do_sched_high;
extern char     *msg_sched_called;
extern char     *msg_sched_nocall;
extern pbs_list_head svr_deferred_req;
extern char	*msg_noloopbackif;
extern char	*msg_daemonname;

int scheduler_jobs_stat = 0;	/* set to 1 once scheduler queried jobs in a cycle*/
extern int svr_unsent_qrun_req;
#define PRIORITY_CONNECTION 1

/**
 * @brief
 * 		am_jobs - array of pointers to jobs which were moved or which had certain
 * 		attributes altered (qalter) while a schedule cycle was in progress.
 *		If a job in the array is run by the scheduler in the cycle, that run
 *		request is rejected as the move/modification may impact the job's
 *		requirements and placement.
 */
static struct   am_jobs {
	int   am_used;		/* number of jobs in the array  */
	int   am_max;		/* number of slots in the array */
	job **am_array;		/* pointer the malloc-ed array  */
} am_jobs = { 0, 0, NULL };


/* Functions private to this file */
static void scheduler_close(int);

/**
 * @brief
 * 		catchalrm	-	put a timeout alarm in case of timeout occurs when contacting the scheduler.
 *
 * @param[in]	sig	-	not used here.
 */
void
catchalrm(int sig)
{
	log_event(PBSEVENT_SCHED, PBS_EVENTCLASS_SERVER, LOG_NOTICE,
		server_name, "timeout attempting to contact scheduler");
}

/**
 * @brief
 *		Sends 'cmd'  over to network 'sock', and if 'cmd' is SCH_SCHEDULE_AJOB,  *	sends also the 'jobid'.
 *
 * @param[in]	sock	-	communication endpoint
 * @param[in]	cmd	-	the command to send
 * @param[in]	identifier -	the jobid to send if 'cmd' is SCH_SCHEDULE_AJOB
 * 			   -	the index of the server if 'cmd' is SCH_SVR_IDENTIFIER
 *
 * @return	int
 * @retval	0	for success
 * @retval	-1	for failure
 */

int
put_sched_cmd(int sock, int cmd, char *identifier)
{
	int   ret;

	DIS_tcp_funcs();
	if ((ret = diswsi(sock, cmd)) != DIS_SUCCESS)
		goto err;

	if (cmd == SCH_SCHEDULE_AJOB || cmd == SCH_SVR_IDENTIFIER) {
		if ((ret = (diswst(sock, identifier))) != DIS_SUCCESS)
			goto err;
	}

	(void)dis_flush(sock);
	return 0;

err:
	sprintf(log_buffer, "write to scheduler failed, err=%d", ret);
	log_event(PBSEVENT_SCHED, PBS_EVENTCLASS_SERVER, LOG_INFO, server_name,
		log_buffer);
	return -1;
}

/**
 * @brief
 * 		find_assoc_sched_jid - find the corresponding scheduler which is responsible
 * 		for handling this job.
 *
 * @param[in]	jid - job id
 * @param[out]	target_sched - pointer to the corresponding scheduler to which the job belongs to
 *
 * @retval - 1  if success
 * 	   - 0 if fail
 */
int
find_assoc_sched_jid(char *jid, pbs_sched **target_sched)
{
	job *pj;
	int t;

	*target_sched = NULL;

	t = is_job_array(jid);
	if ((t == IS_ARRAY_NO) || (t == IS_ARRAY_ArrayJob))
		pj = find_job(jid);		/* regular or ArrayJob itself */
	else
		pj = find_arrayparent(jid); /* subjob(s) */

	if (pj == NULL)
		return 0;

	return find_assoc_sched_pque(pj->ji_qhdr, target_sched);
}

/**
 * @brief
 * 		find_assoc_sched_pque - find the corresponding scheduler which is responsible
 * 		for handling this job.
 *
 * @param[in]	pq		- pointer to pbs_queue
 * @param[out]  target_sched	- pointer to the corresponding scheduler to which the job belongs to
 *
  * @retval - 1 if success
 * 	    - 0 if fail
 */
int
find_assoc_sched_pque(pbs_queue *pq, pbs_sched **target_sched)
{
	pbs_sched *psched;

	*target_sched = NULL;
	if (pq == NULL)
		return 0;

	if (pq->qu_attr[QA_ATR_partition].at_flags & ATR_VFLAG_SET) {
		attribute *part_attr;
		if (strcmp(pq->qu_attr[QA_ATR_partition].at_val.at_str, DEFAULT_PARTITION) == 0) {
			*target_sched = dflt_scheduler;
			return 1;
		}
		for (psched = (pbs_sched*) GET_NEXT(svr_allscheds); psched; psched = (pbs_sched*) GET_NEXT(psched->sc_link)) {
			part_attr = &(psched->sch_attr[SCHED_ATR_partition]);
			if (part_attr->at_flags & ATR_VFLAG_SET) {
				if(!strcmp(part_attr->at_val.at_str, pq->qu_attr[QA_ATR_partition].at_val.at_str)) {
					*target_sched = psched;
					return 1;
				}
			}
		}
	} else {
		*target_sched = dflt_scheduler;
		return 1;
	}
	return 0;

}


/**
 * @brief
 * 		find_sched_from_sock - find the corresponding scheduler which is having
 * 		the given socket.
 *
 * @param[in]	sock	- socket descriptor
 *
 * @retval - pointer to the corresponding pbs_sched object if success
 * 		 -  NULL if fail
 */
pbs_sched *
find_sched_from_sock(int sock)
{
	pbs_sched *psched;

	for (psched = (pbs_sched*) GET_NEXT(svr_allscheds); psched; psched = (pbs_sched*) GET_NEXT(psched->sc_link)) {
		if (psched->scheduler_sock[0] == sock || psched->scheduler_sock[1] == sock)
			return psched;
	}
	return NULL;
}

/**
 * @brief
 * 		contact_sched - open connection to the scheduler and send it a command
 *		Jobid is passed if and only if the cmd is SCH_SCHEDULE_AJOB
 *
 * @param[in]	cmd	- the command to send
 * @param[in]	jobid	- the jobid to send if 'cmd' is SCH_SCHEDULE_AJOB
 */

int
contact_sched(int cmd, char *jobid, pbs_sched *psched, conn_origin_t which_conn)
{
	int sock = -1;
	conn_t *conn;
	int my_index = 0;
	/* As we are restricting number of servers to 99 in the worst case(although in reality one can use at the max 5 to 10 servers),
	 * if we convert these ids to string form, we hardly need a char array of length two + 1 for NULL character.
	 */
	char myindex_str[3];
	int sched_sock_arr_index = 0;

#ifdef TCP_USER_TIMEOUT
	int tcp_timeout = TCP_TIMEOUT;
#endif

	if ((cmd == SCH_SCHEDULE_AJOB) && (jobid == NULL))
		return -1;	/* need a jobid */

	if (which_conn == CONN_SCHED_SECONDARY)
		sched_sock_arr_index = 1;

	if (psched->scheduler_sock[sched_sock_arr_index] == CONN_UNKNOWN) {
		/* Under win32, this function does a timeout wait on the non-blocking socket */
		sock = client_to_svr(psched->pbs_scheduler_addr, psched->pbs_scheduler_port, B_RESERVED); /* scheduler connection still uses resv-ports */
		if (pbs_errno == PBSE_NOLOOPBACKIF)
			log_err(PBSE_NOLOOPBACKIF, "client_to_svr" , msg_noloopbackif);

		if (sock < 0) {
			log_err(errno, __func__, msg_sched_nocall);
			return -1;
		}

#ifdef TCP_USER_TIMEOUT
		setsockopt(sock, IPPROTO_TCP, TCP_USER_TIMEOUT, (char*) &tcp_timeout, sizeof (tcp_timeout));
#endif

		conn = add_conn_priority(sock, FromClientDIS, psched->pbs_scheduler_addr,
		psched->pbs_scheduler_port, NULL, process_request, PRIORITY_CONNECTION);

		if (!conn) {
			log_err(errno, __func__, "could not find sock in connection table");
			return -1;
		}
		conn->cn_authen |= PBS_NET_CONN_FROM_PRIVIL | PBS_NET_CONN_AUTHENTICATED;

		conn->conn_origin = which_conn;

		strcpy(conn->cn_username, PBS_SCHED_DAEMON_NAME);
		conn->cn_credid = strdup(PBS_SCHED_DAEMON_NAME);
		if (conn->cn_credid == NULL) {
			log_err(errno, __func__, "Out of memory!");
			return -1;
		}
		conn->cn_auth_config = make_auth_config(AUTH_RESVPORT_NAME, "",
							pbs_conf.pbs_exec_path,
							pbs_conf.pbs_home_path,
							(void *)log_event);
		if (conn->cn_auth_config == NULL) {
			log_err(errno, __func__, "Out of memory!");
			return -1;
		}
		DIS_tcp_funcs();
		transport_chan_set_ctx_status(sock, AUTH_STATUS_CTX_READY, FOR_AUTH);
		net_add_close_func(sock, scheduler_close);

		if (set_nodelay(sock) == -1) {
			snprintf(log_buffer, sizeof(log_buffer), "cannot set nodelay on connection %d (errno=%d)\n", sock, errno);
			log_err(-1, __func__, log_buffer);
			return -1;
		}

	/*TODO remove this block of code later */
	/* 	if ((myindex = get_svr_index(&self)) == -1) {
			log_err(-1, __func__, "Wrong server index");
			return -1;
		} */
		snprintf(myindex_str, sizeof(myindex_str), "%d", my_index);

		if (put_sched_cmd(sock, SCH_SVR_IDENTIFIER, myindex_str) < 0) {
			close_conn(sock);
			return (-1);
		}

		psched->scheduler_sock[sched_sock_arr_index] = sock;
		return sock;
	}

	/* send command to Scheduler */

	if (put_sched_cmd(psched->scheduler_sock[sched_sock_arr_index], cmd, jobid) < 0) {
		close_conn(psched->scheduler_sock[sched_sock_arr_index]);
		return -1;
	}
	psched->sched_cycle_started = 1;

	(void)sprintf(log_buffer, msg_sched_called, cmd);
	log_event(PBSEVENT_SCHED, PBS_EVENTCLASS_SERVER, LOG_INFO,
		server_name, log_buffer);
	return (psched->scheduler_sock[sched_sock_arr_index]);
}

/**
 * @brief
 * 		schedule_high	-	send high priority commands to the scheduler
 *
 * @return	int
 * @retval  1	: scheduler busy
 * @retval  0	: scheduler notified
 * @retval	-1	: error
 */
int
schedule_high(pbs_sched *psched)
{
	int s;

	if (psched == NULL)
		return -1;

	if (psched->sched_cycle_started == 0) {
		if ((s = contact_sched(psched->svr_do_sched_high, NULL, psched, CONN_SCHED_PRIMARY)) < 0) {
			set_sched_state(psched, SC_DOWN);
			return -1;
		}
		psched->svr_do_sched_high = SCH_SCHEDULE_NULL;
		set_sched_state(psched, SC_SCHEDULING);
		return 0;
	} else
		return 1;
}

/**
 * @brief
 * 		Contact scheduler and direct it to run a scheduling cycle
 *		If a request is already outstanding, skip this one.
 *
 * @return	int
 * @retval	-1	: error
 * @reval	0	: scheduler notified
 * @retval	+1	: scheduler busy
 *
 * @par Side Effects:
 *     the global variable (first_time) is changed.
 *
 * @par MT-safe: No
 */

int
schedule_jobs(pbs_sched *psched)
{
	int cmd;
	int s;
	static int first_time = 1;
	struct deferred_request *pdefr;
	char  *jid = NULL;

	if (psched == NULL)
		return -1;

	if (first_time)
		cmd = SCH_SCHEDULE_FIRST;
	else
		cmd = psched->svr_do_schedule;

	if (psched->sched_cycle_started == 0) {
		/* are there any qrun requests from manager/operator */
		/* which haven't been sent,  they take priority      */
		pdefr = (struct deferred_request *)GET_NEXT(svr_deferred_req);
		while (pdefr) {
			if (pdefr->dr_sent == 0) {
				s = is_job_array(pdefr->dr_id);
				if (s == IS_ARRAY_NO) {
					if (find_job(pdefr->dr_id) != NULL) {
						jid = pdefr->dr_id;
						cmd = SCH_SCHEDULE_AJOB;
						break;
					}
				} else if ((s == IS_ARRAY_Single) ||
					(s == IS_ARRAY_Range)) {
					if (find_arrayparent(pdefr->dr_id) != NULL) {
						jid = pdefr->dr_id;
						cmd = SCH_SCHEDULE_AJOB;
						break;
					}
				}
			}
			pdefr = (struct deferred_request *)GET_NEXT(pdefr->dr_link);
		}

		if ((s = contact_sched(cmd, jid,  psched, CONN_SCHED_PRIMARY)) < 0) {
			set_sched_state(psched, SC_DOWN);
			return -1;
		}
		else if (pdefr != NULL)
			pdefr->dr_sent = 1;   /* mark entry as sent to sched */
		psched->svr_do_schedule = SCH_SCHEDULE_NULL;

		set_sched_state(psched, SC_SCHEDULING);

		first_time = 0;

		/* if there are more qrun requests queued up, reset cmd so */
		/* they are sent when the Scheduler completes this cycle   */
		pdefr = GET_NEXT(svr_deferred_req);
		while (pdefr) {
			if (pdefr->dr_sent == 0) {
				pbs_sched *target_sched;
				if (find_assoc_sched_jid(pdefr->dr_preq->rq_ind.rq_queuejob.rq_jid, &target_sched))
					target_sched->svr_do_schedule = SCH_SCHEDULE_AJOB;
				break;
			}
			pdefr = (struct deferred_request *)GET_NEXT(pdefr->dr_link);
		}
	} else
		return 1;

	return 0;

}

/**
 * @brief
 * 		scheduler_close - connection to scheduler has closed, clear scheduler_called
 * @par
 * 		Connection to scheduler has closed, mark scheduler sock as
 *		closed with -1 and if any clean up any outstanding deferred scheduler
 *		requests (qrun).
 * @par
 * 		Perform some cleanup as connection to scheduler has closed
 *
 * @param[in]	sock	-	communication endpoint.
 * 							closed (scheduler connection) socket, not used but
 *							required to match general prototype of functions called when
 *							a socket is closed.
 * @return	void
 */

static void
scheduler_close(int sock)
{
	pbs_sched *psched;

	psched = find_sched_from_sock(sock);

	if (psched == NULL)
		return;

	psched->sched_cycle_started = 0;


	if ((sock != -1) && (sock == psched->scheduler_sock[1])) {
		psched->scheduler_sock[1] = CONN_UNKNOWN;
		return;	/* nothing to check if scheduler_sock2 */
	}

	psched->scheduler_sock[0] = CONN_UNKNOWN;
	set_sched_state(psched, SC_IDLE);

	/* clear list of jobs which were altered/modified during cycle */
	am_jobs.am_used = 0;
	scheduler_jobs_stat = 0;

	handle_deferred_cycle_close();

}

/**
 * @brief
 * 		Add a job to the am_jobs array, called when a job is moved (locally)
 *		or modified (qalter) during a scheduling cycle
 *
 * @param[in]	pjob	-	pointer to job to add to the array.
 */
void
am_jobs_add(job *pjob)
{
	if (am_jobs.am_used == am_jobs.am_max) {
		/* Need to expand the array, increase by 4 slots */
		job **tmp = realloc(am_jobs.am_array, sizeof(job *) * (am_jobs.am_max + 4));
		if (tmp == NULL)
			return;	/* cannot increase array, so be it */
		am_jobs.am_array = tmp;
		am_jobs.am_max  += 4;
	}
	*(am_jobs.am_array + am_jobs.am_used++) = pjob;
}

/**
 * @brief
 * 		Determine if the job in question is in the list of moved/altered
 *		jobs.  Called when a run request for a job comes from the Scheduler.
 *
 * @param[in]	pjob	-	pointer to job in question.
 *
 * @return	int
 * @retval	0	- job not in list
 * @retval	1	- job is in list
 */
int
was_job_alteredmoved(job *pjob)
{
	int i;
	for (i=0; i<am_jobs.am_used; ++i) {
		if (*(am_jobs.am_array+i) == pjob)
			return 1;
	}
	return 0;
}

/**
 * @brief
 * 		set_scheduler_flag - set the flag to call the Scheduler
 *		certain flag values should not be overwritten
 *
 * @param[in]	flag	-	scheduler command.
 * @parm[in] psched -   pointer to sched object. Then set the flag only for this object.
 *                                     NULL. Then set the flag for all the scheduler objects.
 */
void
set_scheduler_flag(int flag, pbs_sched *psched)
{
	int single_sched;

	if (psched)
		single_sched = 1;
	else {
		single_sched = 0;
		psched = (pbs_sched*) GET_NEXT(svr_allscheds);
	}

	for (; psched ; psched = (pbs_sched*) GET_NEXT(psched->sc_link)) {
		/* high priority commands:
		 * Note: A) usually SCH_QUIT is sent directly and not via here
		 *       B) if we ever add a 3rd high prio command, we can lose them
		 */
		if (flag == SCH_CONFIGURE || flag == SCH_QUIT) {
			if (psched->svr_do_sched_high == SCH_QUIT)
				return; /* keep only SCH_QUIT */

			psched->svr_do_sched_high = flag;
		}
		else
			psched->svr_do_schedule = flag;
		if (single_sched)
			break;
	}

}

/**
 * @brief
 * 		Connects to the Scheduler requested.
 *
 * @param[in]	pjob	-	pointer to scheduler object
 *
 * @return	void
 */
void
connect_to_scheduler(pbs_sched *psched)
{
	int sock;
	sock = contact_sched(SCH_SCHEDULE_NULL, NULL, psched, CONN_SCHED_PRIMARY);
	if (sock != -1) {
		if (contact_sched(SCH_SCHEDULE_NULL, NULL, psched, CONN_SCHED_SECONDARY) == -1)
			close_conn(sock);
		else
			set_sched_state(psched, SC_IDLE);
	}
}

/**
 * @brief
 * 		Connects to the Scheduler requested.
 *
 * @param[in]	psched	-	pointer to scheduler object
 * @param[in] state	-	state of the scheduler
 *
 * @return	void
 */
void
set_sched_state(pbs_sched *psched, char *state)
{
	 set_attr_svr(&(psched->sch_attr[(int) SCHED_ATR_sched_state]),
			 &sched_attr_def[(int) SCHED_ATR_sched_state], state);
	 server.sv_attr[(int)SRV_ATR_State].at_flags |= ATR_VFLAG_MODCACHE;
}

/**
 * @brief
 * 		recv_cycle_end - Receives end of cycle notification from the corresponding Scheduler
 *
 * @param[in]	sock	-	socket to read
 *
 * @return	int
 * @retval	0	: on success
 * @retval	-1	: on error
 */
int
recv_cycle_end(int sock)
{
	pbs_sched *psched;
	int rc;

	for (psched = (pbs_sched*) GET_NEXT(svr_allscheds); psched; psched = (pbs_sched*) GET_NEXT(psched->sc_link)) {
		if (psched->scheduler_sock[1] == sock) {
			DIS_tcp_funcs();
			psched->sched_cycle_started = disrsi(sock, &rc);

			if (rc != 0) {
				psched->scheduler_sock[1] = CONN_UNKNOWN;
				psched->sched_cycle_started = 0;
				set_sched_state(psched, SC_DOWN);
			} else
				set_sched_state(psched, SC_IDLE);

			/* clear list of jobs which were altered/modified during cycle */
			am_jobs.am_used = 0;
			scheduler_jobs_stat = 0;
			handle_deferred_cycle_close();

			if (rc == DIS_EOF)
				rc = -1;

			return rc;
		}
	}

	return 0;
}

/**
 * @brief
 * 		handle_deferred_cycle_close - Handles deferred requests during scheduling cycle closure
 *
 * @return	void
 */
void
handle_deferred_cycle_close()
{
	struct deferred_request *pdefr;

	/*
	 *	If a deferred (from qrun) had been sent to the Scheduler and is still
	 *	there, then the Scheduler must have closed the connection without
	 *	dealing with the job.  Tell qrun it failed if the qrun connection
	 *	is still there.
	 *      If any qrun request is pending in the deffered list, set svr_unsent_qrun_req so
	 * 	they are sent when the Scheduler completes this cycle
	 */
	pdefr = (struct deferred_request *)GET_NEXT(svr_deferred_req);
	while (pdefr) {
		struct deferred_request *next_pdefr = (struct deferred_request *)GET_NEXT(pdefr->dr_link);
		if (pdefr->dr_sent != 0) {
			log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB,
				LOG_NOTICE, pdefr->dr_id,
				"deferred qrun request to scheduler failed");
			if (pdefr->dr_preq != NULL)
				req_reject(PBSE_INTERNAL, 0, pdefr->dr_preq);
			/* unlink and free the deferred request entry */
			delete_link(&pdefr->dr_link);
			free(pdefr);
		}
		else if((pdefr->dr_sent == 0) && (svr_unsent_qrun_req == 0))
			svr_unsent_qrun_req = 1;

		pdefr = next_pdefr;
	}

}


